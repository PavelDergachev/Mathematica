(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BiotSavart`"];


(* ::Input::Initialization:: *)
BiotSavart::usage="BiotSavart is a package to specify current carrying coils and evaluate their field values. The package works with wire objects (\!\(\*
StyleBox[\"WireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireRectangle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireCurcularArd\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireEllipse\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireEllipsoidalArc\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireSpline\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireGroup\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireRepeated\",\nFontSlant->\"Italic\"]\)), constructor functions (\!\(\*
StyleBox[\"MakeWireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"MakeWireRectangle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"MakeWireSpline\",\nFontSlant->\"Italic\"]\), etc., as well as \!\(\*
StyleBox[\"TranslateWire\",\nFontSlant->\"Italic\"]\) to displace the origin of a wire), wire plotting functions (\!\(\*
StyleBox[\"DrawWire\",\nFontSlant->\"Italic\"]\)) that take wire specifications as an argument, and field evaluation functions (\!\(\*
StyleBox[\"MagneticVectorPotential\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"MagneticInduction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"MagneticInductionGradient\",\nFontSlant->\"Italic\"]\)) that require both a wire specification, and an evaluation point. Please consult the individual functions for further details.";


(* ::Input::Initialization:: *)
WireColor::usage="\!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\) is a symbol rule for the color of a loop. Used in drawing the loop. See \!\(\*
StyleBox[\"DrawCurrentLoop\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\).";


(* ::Input::Initialization:: *)
WireSegment::usage="\!\(\*
StyleBox[\"WireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(n\)]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"colorspec\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a \!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\) carrying wire with at least one straight segment defined by \!\(\*SubscriptBox[\(p\), \(1\)]\) and \!\(\*SubscriptBox[\(p\), \(2\)]\), and possibly all the way to \!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(n\)]\).  \!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)The \!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\) of the wire is specified by a rule: \!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"->\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)See \!\(\*
StyleBox[\"Make\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireSegment\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireRectangle::usage="\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"translation\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"direction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"xlength\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"ywidth\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"angle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a rectangular current loop in space. The current loop is defined to have its edges defined along the coordinate x and y axes, which are rotated anti-clockwise by the specified angle before the surface normal is tilted to direction. The current loop's normal points in the specified direction. The color of a loop is specified by a rule: \!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\). See MakeWireRectangle[] for a constructor.";


(* ::Input::Initialization:: *)
WireCircle::usage="\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"translation\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"direction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"colorspec\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a circular current loop in space. The circle's surface normal points in the specified direction. The wire circle has a specified \!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\). The \!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\) of the wire is specified by a rule: \!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"->\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\). See \!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireCircularArc::usage="\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"translation\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"], \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"], \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"colorspec\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a circular wire arc. See \!\(\*
StyleBox[\"MakeWireCircularArc\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireEllipse::usage="NOT YET DEFINED. See \!\(\*
StyleBox[\"MakeWireEllipse\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireEllipsoidalArc::usage="NOT YET DEFINED. See \!\(\*
StyleBox[\"MakeWireEllipsoidalArc\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireSpline::usage="\!\(\*
StyleBox[\"WireSpline\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"3\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"4\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"colorspec\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a spline shaped wire in space. The four control points \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"3\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"4\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\) are specified with 3 cartesian coordinates. The \!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\) of the wire is specified by a rule: \!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"->\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\). See \!\(\*
StyleBox[\"MakeWireSpline\",\nFontSlant->\"Italic\"]\)[] for a constructor.";


(* ::Input::Initialization:: *)
WireGroup::usage="\!\(\*
StyleBox[\"WireGroup\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"w\", \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"w\", \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[\"w\", \"n\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) groups a list of two or more wire objects into a group that will be treated as a unit for the purposes of drawing or field computation.";


(* ::Input::Initialization:: *)
WireRepeated::usage="\!\(\*
StyleBox[\"WireRepeated\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"w\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dx\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dy\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dz\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) builds a composite object that is repeated \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) times with the provided spatial offset \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dx\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dy\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"dz\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)Any wire object, including a grouped or repeated object, can be provided as argument.";


(* ::Input::Initialization:: *)
VectorPotentialMultipole::usage="VectorPotentialMultipole[{\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, \!\(\*SubscriptBox[\(r\), \(i\)]\), \!\(\*SubscriptBox[\(r\), \(o\)]\), {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}] defines the multipole expansion of the vector potential of a wire object relative to a centre {\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, with inner and outer radii \!\(\*SubscriptBox[\(r\), \(i\)]\) and \!\(\*SubscriptBox[\(r\), \(o\)]\). At points further than the outer radius, only the dipole term is required. At points within the inner and outer radius, the entire expansion is needed. Inside the inner radius, an explicit formula is needed for the field. The moments are defined by {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}.";

MagneticInductionMultipole::usage="MagneticInductionMultipole[{\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, \!\(\*SubscriptBox[\(r\), \(i\)]\), \!\(\*SubscriptBox[\(r\), \(o\)]\), {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}] defines the multipole expansion of the magnetic induction of a wire object relative to a centre {\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, with inner and outer radii \!\(\*SubscriptBox[\(r\), \(i\)]\) and \!\(\*SubscriptBox[\(r\), \(o\)]\). At points further than the outer radius, only the dipole term is required. At points within the inner and outer radius, the entire expansion is needed. Inside the inner radius, an explicit formula is needed for the field. The moments are defined by {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}.";

MagneticInductionGradientMultipole::usage="MagneticInductionGradientMultipole[{\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, \!\(\*SubscriptBox[\(r\), \(i\)]\), \!\(\*SubscriptBox[\(r\), \(o\)]\), {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}] defines the multipole expansion of the magnetic induction gradient of a wire object relative to a centre {\!\(\*SubscriptBox[\(c\), \(x\)]\),\!\(\*SubscriptBox[\(c\), \(y\)]\),\!\(\*SubscriptBox[\(c\), \(z\)]\)}, with inner and outer radii \!\(\*SubscriptBox[\(r\), \(i\)]\) and \!\(\*SubscriptBox[\(r\), \(o\)]\). At points further than the outer radius, only the dipole term is required. At points within the inner and outer radius, the entire expansion is needed. Inside the inner radius, an explicit formula is needed for the field. The moments are defined by {\!\(\*SubscriptBox[\(m\), \(0\)]\),\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...\!\(\*SubscriptBox[\(m\), \(n\)]\)}.";

MultipoleSegment::usage="MultipoleSegment[m, wire] defines a multipole expansion m of a current carrying wire.  The multipole can be either for the vector potential, magnetic induction, or the magnetic induction gradient. The wire is specified by a wire object. MultipoleSegment[{\!\(\*SubscriptBox[\(m\), \(1\)]\),\!\(\*SubscriptBox[\(m\), \(2\)]\),...,\!\(\*SubscriptBox[\(m\), \(m\)]\)}, wire] specifies multipoles for more than one field associated with the wire.";


(* ::Input::Initialization:: *)
MakeWireSegment::usage="\!\(\*
StyleBox[\"MakeWireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(n\)]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"defines\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"wire\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"  \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"as\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"set\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"of\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"straight\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"segments\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"specified\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"by\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"...\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(n\)]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)At least two coordinates are expected\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\) specifies the colour of the line.  The function returns a WireSegment[] object.";


(* ::Input::Initialization:: *)
MakeWireRectangle::usage="NOT YET DEFINED. The function returns a WireRectangle[] object.";


(* ::Input::Initialization:: *)
MakeWireCircle::usage="\!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"opts\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) defines a planar circular current loop, with given radius and anti-clockwise current intensity. The loop lies in the x-y plane, centered at the origin. \!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\) specifies the colour of the line. \n \!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"opts\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) additionally specifies an offset of the current loop w.r.t. the origin. \n \!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"position\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"direction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"opts\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) additionally specifies the direction of the loop's surface normal. The function returns a WireCircle[] object.";


(* ::Input::Initialization:: *)
MakeWireCircularArc::usage="\!\(\*
StyleBox[\"MakeWireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"radius\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"], \"1\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"\[Theta]\",\nFontSlant->\"Italic\"], \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"opts\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"defines\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"circular\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"arc\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"wire\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"lying\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"in\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"-\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"y\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"plane\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"whose\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"end\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"points\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"are\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"specified\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"by\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"two\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"rotation\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"angles\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"about\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"z\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"-\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"axis\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"and\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"measured\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"anti\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"-\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"clockwise\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"from\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"-\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"axis\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)";


(* ::Input::Initialization:: *)
MakeWireEllipse::usage="Not defined.";


(* ::Input::Initialization:: *)
MakeWireEllipsoidalArc::usage="Not defined.";


(* ::Input::Initialization:: *)
MakeWireSpline::usage="\!\(\*
StyleBox[\"MakeWireSpline\",\nFontSlant->\"Italic\"]\)[{\!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(1\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(2\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\",\nFontSlant->\"Italic\"], \(3\)]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*SubscriptBox[\(p\), \(4\)]\)}\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"current\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireColor\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"color\",\nFontSlant->\"Italic\"]\)] defines a Bezier spline wire with four control points. The first and last points lie on the line. The other two points control the curvature of the line, and also define the tangents at the start and end points. Since no compact expression is available, the field values for the spline are determined by numerical integration.";


(* ::Input::Initialization:: *)
MakeWireGroup::usage="MakeWireGroup[]";


(* ::Input::Initialization:: *)
MakeWireRepeated::usage="MakeWireRepeated[]";


(* ::Input::Initialization:: *)
TranslateWire::usage="\!\(\*
StyleBox[\"TranslateWire\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"w\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"y\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"z\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) translates the wire object by the specified offset.";


(* ::Input::Initialization:: *)
MakeMultipoleSegment::usage="MakeMultipoleSegment[s, f] defines a multipole expansion object of a specific field \!\(\*
StyleBox[\"f\",\nFontSlant->\"Italic\"]\) for a given segment \!\(\*
StyleBox[\"s\",\nFontSlant->\"Italic\"]\). The optional argument f specifies the field that will be approximated via one of the following strings: VectorPotential, MagneticInduction, MagneticInductionGradient, or All. If no argument is given, the vector potential will be defined. If more than one field is required, the field strings are supplied as a list. All specifies that all the fields are required.";


(* ::Input::Initialization:: *)
DrawWire::usage="\!\(\*
StyleBox[\"DrawWire\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) produces a 3D graphic of a \!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\). The \!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\) must be specified as one or more \!\(\*
StyleBox[\"WireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\) \!\(\*
StyleBox[\"WireRectangle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)or\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireCircularArc\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireEllipse\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireEllipsoidalArc\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"or\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireSpline\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) objects.";


(* ::Input::Initialization:: *)
MagneticVectorPotential::usage="Watch this spot";


(* ::Input::Initialization:: *)
MagneticInduction::usage="\!\(\*
StyleBox[\"MagneticInduction\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"y\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"z\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) computes the cartesian vector magnetic induction of a \!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\) at the specified \!\(\*
StyleBox[\"{\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"x\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"y\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"z\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"}\",\nFontSlant->\"Italic\"]\) position. This evaluation point may be symbolic, yielding an en expression. The \!\(\*
StyleBox[\"wireobject\",\nFontSlant->\"Italic\"]\) must be specified as one or more \!\(\*
StyleBox[\"WireSegment\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"WireCircle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) or \!\(\*
StyleBox[\"WireRectangle\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"[\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"]\",\nFontSlant->\"Italic\"]\) objects.";


(* ::Input::Initialization:: *)
MagneticInductionGradient::usage="Watch this spot";


(* ::Input::Initialization:: *)
LorenzForce::usage="Watch this spot";


(* ::Input::Initialization:: *)
Begin["Private`"];


(* ::Input::Initialization:: *)
Options[MakeWireSegment]={WireColor->Red};

MakeWireSegment[positions:{{_,_,_},{_,_,_},___},current_,opts:OptionsPattern[]]:=
Block[{rules}, 
rules=FilterRules[{opts}, Options[MakeWireRectangle]];
WireSegment[positions,current, WireColor->(WireColor/.Join[rules,Options[MakeWireRectangle]])]
];

TranslateWire[WireSegment[positions:{{_,_,_},{_,_,_},___},current_,color_],p:{_,_,_}]:=
WireSegment[(p+#)&/@positions,current,color];


(* ::Input::Initialization:: *)
Options[MakeWireRectangle]={WireColor->Red};

MakeWireRectangle[edge_,current_,opts:OptionsPattern[]]:=
Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireRectangle]];
WireRectangle[{0,0,0},{0,0,1},{edge,edge,0},current,WireColor->(WireColor/.Join[rules,Options[MakeWireRectangle]])]
];

MakeWireRectangle[position:{_,_,_},edge_,current_,opts:OptionsPattern[]]:=
Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireRectangle]];
WireRectangle[position,{0,0,1},{edge,edge,0},current,WireColor->(WireColor/.Join[rules,Options[MakeWireRectangle]])]
];

MakeWireRectangle[position:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,opts:OptionsPattern[]]:=
Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireRectangle]];
WireRectangle[position,direction/Norm[direction],{xedge,yedge,angle},current,WireColor->(WireColor/.Join[rules,Options[MakeWireRectangle]])]
];

TranslateWire[WireRectangle[translation:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,color_],p:{_,_,_}]:=
WireRectangle[translation+p,direction,{xedge,yedge,angle},current,color];


(* ::Input::Initialization:: *)
Options[MakeWireCircle]={WireColor->Red};

MakeWireCircle[radius_,current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircle]];
WireCircle[{0,0,0},{0,0,1},radius,current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircle]])]
];

MakeWireCircle[translation:{_,_,_},radius_,current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircle]];
WireCircle[translation,{0,0,1},radius,current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircle]])]
];

MakeWireCircle[translation:{_,_,_},direction:{_,_,_},radius_,current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircle]];
WireCircle[translation,direction/Norm[direction],radius,current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircle]])]
];

TranslateWire[WireCircle[translation:{_,_,_},direction:{_,_,_},radius_,current_,color_],p:{_,_,_}]:=
WireCircle[translation+p,direction,radius,current,color];


(* ::Input::Initialization:: *)
Options[MakeWireCircularArc]={WireColor->Red};

MakeWireCircularArc[radius_,{theta0_,theta1_},current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircularArc]];
WireCircularArc[{0,0,0},{0,0,1},radius,{theta0,theta1},current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircularArc]])]
];

MakeWireCircularArc[translation:{_,_,_},radius_,{theta0_,theta1_},current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircularArc]];
WireCircularArc[translation,{0,0,1},radius,{theta0,theta1},current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircularArc]])]
];

MakeWireCircularArc[translation:{_,_,_},direction:{_,_,_},radius_,{theta0_,theta1_},current_,opts:OptionsPattern[]]:=Block[{rules},
rules=FilterRules[{opts}, Options[MakeWireCircularArc]];
WireCircularArc[translation,direction/Norm[direction],radius,{theta0,theta1},current,WireColor->(WireColor/.Join[rules,Options[MakeWireCircularArc]])]
];

TranslateWire[WireCircularArc[translation:{_,_,_},direction:{_,_,_},radius_,{theta0_,theta1_},current_,color_],p:{_,_,_}]:=
WireCircularArc[translation+p,direction,radius,{theta0,theta1},current,color];


(* ::Input::Initialization:: *)
Options[MakeWireEllipse]={WireColor->Red};



(* ::Input::Initialization:: *)
Options[MakeWireEllipsoidalArc]={WireColor->Red};



(* ::Input::Initialization:: *)
Options[MakeWireSpline]={WireColor->Red};

MakeWireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,opts:OptionsPattern[]]:=
Block[{rules}, 
rules=FilterRules[{opts}, Options[MakeWireSpline]];
WireSpline[positions,current, WireColor->(WireColor/.Join[rules,Options[MakeWireSpline]])]
];

TranslateWire[WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_],p:{_,_,_}]:=
WireSpline[(p+#)&/@positions,current,color];


(* ::Input::Initialization:: *)
MakeWireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}]:=WireGroup[g];

TranslateWire[WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}],p:{_,_,_}]:=
WireGroup[TranslateWire[#,p]&/@g];


(* ::Input::Initialization:: *)
MakeWireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_]:=
WireRepeated[o,offset,nRepeat];

TranslateWire[WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_],p:{_,_,_}]:=
WireRepeated[TranslateWire[o,p],offset,nRepeat];


(* ::Input::Initialization:: *)
MakeMultipoleSegment[ws:WireSegment[positions:{left:{_,_,_},right:{_,_,_}},current_,color_],field_String]:=Block[{cg,rDash,lWire,n=20,VectorPotentialLineIntegration},
rDash[s_]:=((1-s) left+s right)-cg; (* Interpolate the position on the line *)

VectorPotentialLineIntegration[]:=
FunctionInterpolation[NIntegrate[(s lWire)^# LegendreP[#,Cos[\[Phi]]],{s,0,1}],{\[Phi],0,2\[Pi]}]&/@Range[0,n-1];

(* Chop[FunctionInterpolation[NIntegrate[(Sqrt[rDash[s].rDash[s]])^#LegendreP[#,Cos[\[Phi]]],{s,0,1},MaxRecursion\[Rule]2,Method\[Rule]{"LobattoKronrodRule","SymbolicProcessing"\[Rule]False}],{\[Phi],0,\[Pi]}]]&/@Range[0,n-1]; For evaluation, we need to consider the projection allowing the cone. *)

If[field=="VectorPotential",
cg=(left+right)/2;
lWire=(right-left).(right-left);
MultipoleSegment[VectorPotentialMultipole[cg,lWire,5 lWire,VectorPotentialLineIntegration[]],ws]
]
];

(*MakeMultipoleSegment[ws:WireSegment[positions:{{_,_,_},{_,_,_},..},current_,color_],field_String]:=
MakeMultipoleSegment[WireSegment[#,current,color],field]&/@Partition[positions,2,1];*)


(* ::Input::Initialization:: *)
MakeMultipoleSegment[ws:WireRectangle[translation:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,color_],field_String]:=Block[{},
{}
];


(* ::Input::Initialization:: *)
MakeMultipoleSegment[ws:WireCircle[translation:{_,_,_},direction:{_,_,_},radius_,current_,color_],field_String]:=Block[{},
{}
];

MakeMultipoleSegment[ws:WireCircularArc[translation:{_,_,_},direction:{_,_,_},radius_,{theta0_,theta1_},current_,color_],field_String]:=Block[{},
{}
];


(* ::Input::Initialization:: *)
MakeMultipoleSegment[ws:WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_],field_String]:=Block[{},
{}
];

MakeMultipoleSegment[ws:WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}],field_String]:=Block[{},
{}
];


(* ::Input::Initialization:: *)
MakeMultipoleSegment[ws:WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_],field_String]:=Block[{},
{}
];


(* ::Input::Initialization:: *)
Options[DrawWire]={WireColor->Red};

DrawWire[l:{__},opts:OptionsPattern[]]:=DrawWire[#,opts]&/@l;


(* ::Input::Initialization:: *)
DrawWire[l:WireSegment[positions:{{_,_,_},{_,_,_},___},current_,color_],opts:OptionsPattern[]]:=
Block[{rules},
rules=FilterRules[{opts}, Options[DrawWire]];
If[Sign[current]==-1,
{WireColor/.Join[rules,{color}],Arrow[Tube[Reverse[positions]]]},
{WireColor/.Join[rules,{color}],Arrow[Tube[positions]]}
]
];


(* ::Input::Initialization:: *)
DrawWire[l:WireRectangle[translation:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,color_],opts:OptionsPattern[]]:=Block[{coordinates,rules},
rules=FilterRules[{opts}, Options[DrawWire]];
coordinates=(RotationMatrix[angle,{0,0,1}].#)&/@{{-(xedge/2),-(yedge/2),0},{xedge/2,-(yedge/2),0},{xedge/2,yedge/2,0},{-(xedge/2),yedge/2,0},{-(xedge/2),-(yedge/2),0}};
If[Sign[current]==-1,
coordinates=Reverse[(RotationMatrix[{{0,0,1},direction}].#+translation)&/@coordinates],
coordinates=(RotationMatrix[{{0,0,1},direction}].#+translation)&/@coordinates
];
{WireColor/.Join[rules,{color}],Arrow[Tube[coordinates,xedge 0.01],xedge 0.05]}
];


(* ::Input::Initialization:: *)
DrawWire[l:WireCircle[translation:{_,_,_},direction:{_,_,_},radius_,current_,color_],opts:OptionsPattern[]]:=Block[{coordinates,rules,backbone},
rules=FilterRules[{opts}, Options[DrawWire]];
rules=FilterRules[{opts}, Options[DrawWire]];
backbone=splineCircle[{0,0,0},radius,{0,2\[Pi]}];
backbone=BSplineCurve@@Join[{((RotationMatrix[{{0,0,1},direction}].#)+translation)&/@First[List@@backbone]},
Rest[List@@backbone]];
{WireColor/.Join[rules,{color}],Arrow[backbone,radius 0.05]}
];

DrawWire[l:WireCircularArc[translation:{_,_,_},direction:{_,_,_},radius_,{theta0_,theta1_},current_,color_],opts:OptionsPattern[]]:=
Block[{coordinates,rules,backbone},
rules=FilterRules[{opts}, Options[DrawWire]];
backbone=splineCircle[{0,0,0},radius,{theta0,theta1}];
backbone=BSplineCurve@@Join[{((RotationMatrix[{{0,0,1},direction}].#)+translation)&/@First[List@@backbone]},
Rest[List@@backbone]];
{WireColor/.Join[rules,{color}],Arrow[backbone,radius 0.05]}
];

splineCircle[m_List,r_,angles_List: {0,2 \[Pi]}]:=Module[{seg,\[Phi],start,end,pts,w,k},{start,end}=Mod[angles//N,2 \[Pi]];
If[end<=start,end+=2 \[Pi]];
seg=Quotient[end-start//N,\[Pi]/2];
\[Phi]=Mod[end-start//N,\[Pi]/2];
If[seg==4,seg=3;\[Phi]=\[Pi]/2];
pts=r RotationMatrix[start].#&/@Join[Take[{{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1}},2 seg+1],RotationMatrix[seg \[Pi]/2].#&/@{{1,Tan[\[Phi]/2]},{Cos[\[Phi]],Sin[\[Phi]]}}];
If[Length[m]==2,pts=m+#&/@pts,pts=m+#&/@Transpose[Append[Transpose[pts],ConstantArray[0,Length[pts]]]]];
w=Join[Take[{1,1/Sqrt[2],1,1/Sqrt[2],1,1/Sqrt[2],1},2 seg+1],{Cos[\[Phi]/2],1}];
k=Join[{0,0,0},Riffle[#,#]&@Range[seg+1],{seg+1}];
BSplineCurve[pts,SplineDegree->2,SplineKnots->k,SplineWeights->w]]/;Length[m]==2||Length[m]==3


(* ::Input::Initialization:: *)
DrawWire[l:WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_],opts:OptionsPattern[]]:=
Block[{rules},
rules=FilterRules[{opts}, Options[DrawWire]];
If[Sign[current]==-1,
{WireColor/.Join[rules,{color}],Arrow[Tube[BezierCurve[Reverse[positions]]]]},
{WireColor/.Join[rules,{color}],Arrow[Tube[BezierCurve[positions]]]}
]
];


(* ::Input::Initialization:: *)
DrawWire[WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_]]:=
DrawWire[TranslateWire[o,offset #]]&/@Range[0,(nRepeat-1)];


(* ::Input::Initialization:: *)
DrawWire[WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}]]:=
DrawWire[#]&/@g;


(* ::Input::Initialization:: *)
DrawWire[
MultipoleSegment[{(_VectorPotentialMultipole|_MagneticInductionMultipole|_MagneticInductionGradientMultipole)..}, w:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)]]:=
DrawWire[w];


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,_},WireSegment[positions:{{_,_,_},{_,_,_},___},current_,color_]]:=Block[{LineSegment,t,s},
LineSegment[start:{_,_,_},end:{_,_,_}]:=Block[{v},
v=end-start;
t=RotationMatrix[{v,{0,0,1}}];
s=RotationMatrix[{-v,{0,0,1}}];
s.NormalWireSegmentMagneticVectorPotential[t.(p-start),Sqrt[v.v]]
];
10^-7 current (Plus@@((LineSegment@@#)&/@Partition[positions,2,1]))
];

NormalWireSegmentMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,-ArcSinh[-z/(x^2+y^2)]+ArcSinh[(end-z)/(x^2+y^2)]};


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_}, l:WireSegment[positions:{{_,_,_},{_,_,_},___},current_,color_]]:=
Block[{LineSegment,t,s},
LineSegment[start:{_,_,_},end:{_,_,_}]:=Block[{v},
v=end-start;
t=RotationMatrix[{v,{0,0,1}}];
s=RotationMatrix[{-v,{0,0,1}}];
s.NormalWireSegmentMagneticInduction[t.(p-start),Sqrt[v.v]]
];
10^-7 current (Plus@@((LineSegment@@#)&/@Partition[positions,2,1]))
];

NormalWireSegmentMagneticInduction[{x_,y_,z_},end_]:=
{-y,x,0}(z/Sqrt[x^2+y^2+z^2]+(end-z)/Sqrt[x^2+y^2+(end-z)^2])/(x^2+y^2);


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{_,_,_},WireSegment[positions:{{_,_,_},{_,_,_},___},current_,color_]]:=Block[{LineSegment,t,s},
LineSegment[start:{_,_,_},end:{_,_,_}]:=Block[{v},
v=end-start;
t=RotationMatrix[{v,{0,0,1}}];
s=RotationMatrix[{-v,{0,0,1}}];
s.NormalWireSegmentMMagneticInductionGradient[t.(p-start),Sqrt[v.v]]
];
10^-7 current (Plus@@((LineSegment@@#)&/@Partition[positions,2,1]))
];

NormalWireSegmentMMagneticInductionGradient[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticVectorPotential[{_,_,_},r:WireRectangle[position:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,color_]]:=0;


(* ::Input::Initialization:: *)
MagneticInduction[{x_,y_,z_},l:WireRectangle[position:{_,_,_},direction:{_,_,_},{xedge_,yedge_,angle_},current_,color_]]:=
Block[{t,s},
If[direction[[1]]==direction[[2]]==0,
t=RotationMatrix[angle,{0,0,1}];
s=RotationMatrix[-angle,{0,0,1}],
t=RotationMatrix[{{0,0,1},direction}].RotationMatrix[angle,{0,0,1}];
s=RotationMatrix[-angle,{0,0,1}].RotationMatrix[{direction,{0,0,1}}]
];
s.NormalWireRectangleMagneticInduction[t.({x,y,z}-position),{xedge,yedge},current]
];

NormalWireRectangleMagneticInduction[{x_,y_,z_},{xedge_,yedge_},current_]:=
Block[{\[Mu]0=4\[Pi] 10^-7,C,d,r},
C={(xedge/2+x),(xedge/2-x),-(xedge/2-x),-(xedge/2+x)};
d={(y+yedge/2),(y+yedge/2),(y-yedge/2),(y-yedge/2)};
r={Sqrt[C[[1]]^2+d[[1]]^2+z^2],Sqrt[C[[2]]^2+d[[2]]^2+z^2],
Sqrt[C[[3]]^2+d[[3]]^2+z^2],Sqrt[C[[4]]^2+d[[4]]^2+z^2]};
If[r[[1]]==0||r[[2]]==0||r[[3]]==0||r[[4]]==0,
Return[{0,0,0}]
];

{(\[Mu]0 current)/(4\[Pi]) Plus@@((((-1)^(#+1) z)/(r[[#]](r[[#]]+d[[#]])))&/@Range[4]),
(\[Mu]0 current)/(4\[Pi]) Plus@@((((-1)^(#+1) z)/(r[[#]](r[[#]]+(-1)^(#+1) C[[#]])))&/@Range[4]),
(\[Mu]0 current)/(4\[Pi]) Plus@@((((-1)^# d[[#]])/(r[[#]](r[[#]]+(-1)^(#+1) C[[#]]))-(C[[#]]/(r[[#]](r[[#]]+d[[#]]))))&/@Range[4])}
];


(* ::Input::Initialization:: *)
End[];
EndPackage[];


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,0},l:WireCircle[position:{_,_,_},direction:{_,_,_},radius_,current_,color_]]:={0,0,0};

MagneticVectorPotential[p:{_,_,_},l:WireCircle[position:{_,_,_},direction:{_,_,_},radius_,current_,color_]]:=
Block[{t,s,CylindricalToCartesian,CartesianToCylindrical},
CylindricalToCartesian[{r_,\[Phi]_,z_}]:={r Cos[\[Phi]],r Sin[\[Phi]],z};
CartesianToCylindrical[{x_,y_,z_}]:={Sqrt[x^2+y^2],ArcTan[y,x],z};

If[direction[[1]]==direction[[2]]==0,
t=s=IdentityMatrix[3],
t=RotationMatrix[{{0,0,1},direction}];
s=RotationMatrix[{direction,{0,0,1}}]
];
s.CylindricalToCartesian[NormalWireCircleMagneticInduction[CartesianToCylindrical[t.(p-position)],radius,current]]
];

NormalWireCircleMagneticVectorPotential[{r_,\[Phi]_,z_},radius_,current_]:=
Block[{a2,k2,k},
a2=z^2+(radius+r)^2;
k2=4 r radius/a2;
k=Sqrt[k2];
(radius/r)((1-k2/2)EllipticK[k]-EllipticE[k])
];


(* ::Input::Initialization:: *)
MagneticInduction[{_,_,_},WireCircle[{_,_,_},{_,_,_},0,_,_]]:={Indeterminate,Indeterminate,Indeterminate};

MagneticInduction[{x_,y_,z_},l:WireCircle[position:{_,_,_},direction:{_,_,_},radius_,current_,color_]]:=
Block[{t,s},
If[direction[[1]]==direction[[2]]==0,
t=s=IdentityMatrix[3],
t=RotationMatrix[{{0,0,1},direction}];
s=RotationMatrix[{direction,{0,0,1}}]
];
s.NormalWireCircleMagneticInduction[t.({x,y,z}-position),radius,current]
];

NormalWireCircleMagneticInduction[{x_,y_,z_},radius_,current_]:=
Block[{rad2,r2,\[Rho]2,\[Alpha]2,\[Beta]2,\[Gamma],k2,tmp,\[Mu]0=4\[Pi] 10^-7,big=1000, verybig=1000000},
rad2=radius^2;
r2=x^2+y^2+z^2;
\[Rho]2=x^2+y^2;

 If[(\[Rho]2<=(radius/verybig)^2),
Return[ \[Mu]0 current rad2 {(0.75 x z)/Power[rad2+z^2, (5/2)^-1],(0.75 y z)/Power[rad2+z^2, (5/2)^-1],0.5 /Power[rad2+z^2, (3/2)^-1]}]
]; (* Escape formula for positions close to the axis *)

If[r2>rad2 big,
Return[(\[Mu]0 current rad2)/(2Power[r2, (3/2)^-1]) {0,0,1}]
];(* Escape formula for positions far from the axis *)

\[Alpha]2=rad2+r2-2 radius Sqrt[\[Rho]2];
\[Beta]2=rad2+r2+2 radius Sqrt[\[Rho]2];
\[Gamma]=x^2-y^2;
k2=1-\[Alpha]2/\[Beta]2; (* k^2= m *)
(\[Mu]0 current)/(2\[Pi] \[Alpha]2 Sqrt[\[Beta]2]) {(x z)/\[Rho]2 (tmp=((rad2+r2)EllipticE[k2]-\[Alpha]2 EllipticK[k2])),
(y z)/\[Rho]2 tmp,
((rad2-r2)EllipticE[k2]+\[Alpha]2 EllipticK[k2])}
]; 


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{_,_,_},l:WireCircle[position:{_,_,_},direction:{_,_,_},radius_,current_,color_]]:=
Block[{t,s,CylindricalToCartesian,CartesianToCylindrical,IntermediateTensor},
CylindricalToCartesian[{r_,\[Phi]_,z_}]:={r Cos[\[Phi]],r Sin[\[Phi]],z};
CartesianToCylindrical[{x_,y_,z_}]:={Sqrt[x^2+y^2],ArcTan[y,x],z};

If[direction[[1]]==direction[[2]]==0,
t=s=IdentityMatrix[3],
t=RotationMatrix[{{0,0,1},direction}];
s=RotationMatrix[{direction,{0,0,1}}]
];
IntermediateTensor=CylindricalToCartesian[#]&/@Transpose[CylindricalToCartesian[#]&/@Transpose[NormalWireCircleMagneticInductionGradient[CartesianToCylindrical[t.(p-position)],radius,current]]];
s.IntermediateTensor.Transpose[s]
];

(* CASE evaluation point on loop *)
NormalWireCircleMagneticInductionGradient[{radius_,\[Phi]_,0},radius_,current_]:=
Block[{},
{{0,0,0},
{0,0,0},
{0,0,0}}
];
(* CASE evaluation point on axis *)
NormalWireCircleMagneticInductionGradient[{0,\[Phi]_,z_},radius_,current_]:=
Block[{r1},
r1=radius;
{{-3\[Pi] (-z) r1^2/(2(z^2+(r1+r)^2)^(5/2)),0,0},
{0,0,0},
{0,0,3\[Pi] (-z) r1^2/(z^2+(r1+r)^2)^(5/2)}}
];
(* CASE any other point *)
NormalWireCircleMagneticInductionGradient[{r_,\[Phi]_,z_},radius_,current_]:=
Block[{r1,k},
r1=radius;
k=Sqrt[4 r r1/((-z)^2+(r1+r)^2)];
{1/(2 r (z^2+(r1+r)^2)^(3/2)k^2(1-k^2)) {(-z)(P[r,z,r1,k]EllipticK[k]+Q[r,z,r1,k]EllipticE[k]),0,k^2(S[r,z,r1,k]EllipticK[k]+T[r,z,r1,k]EllipticE[k])},
{0,0,0},
1/(2 r (z^2+(r1+r)^2)^(3/2)k^2(1-k^2)) {(S[r,z,r1,k]EllipticK[k]+T[r,z,r1,k]EllipticE[k]),0,(-z)(U[r,z,r1,k]EllipticK[k]+V[r,z,r1,k]EllipticE[k])}}
];

P[r_,z_,r1_,k_]:=(r1+r)k^4+2(4r1-r)k^2-8r1;
Q[r_,z_,r1_,k_]:=2/(1-k^2)((r1+r) k^6-r k^4-(6r1-r)k^2+4r1);
S[r_,z_,r1_,k_]:=k^2((z^2+(r1+r)^2)+(r1+r)^2)-2(r1+r)^2;
T[r_,z_,r1_,k_]:=1/(1-k^2)(((r1+r)^2-z^2)k^4-((z^2+(r1+r)^2)+2(r1+r)^2)k^2+2(r1+r)^2);
U[r_,z_,r1_,k_]:=2r-(r1+r)k^2;
V[r_,z_,r1_,k_]:=2/(1-k^2)((r1+r)k^4-(2r1+r)k^2+r);


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,_},WireCircularArc[position:{_,_,_},direction:{_,_,_},radius_,{\[Phi]1_,\[Phi]2_},current_,color_]]:=
Block[{t,s,CylindricalToCartesian,CartesianToCylindrical,r,\[Phi],\[Zeta]},
CylindricalToCartesian[{r_,\[Phi]_,z_}]:={r Cos[\[Phi]],r Sin[\[Phi]],z};
CartesianToCylindrical[{x_,y_,z_}]:={Sqrt[x^2+y^2],ArcTan[x,y],z};

If[direction[[1]]==direction[[2]]==0,
t=s=IdentityMatrix[3],
t=RotationMatrix[{{0,0,1},direction}];
s=RotationMatrix[{direction,{0,0,1}}]
];
s.CylindricalToCartesian[
NormalWireCircularArcMagneticVectorPotential[CartesianToCylindrical[t.p-position],\[Phi]1,\[Phi]2,radius,0]
]
];

(* This function returns a vector in cylindrical coordinates *)
NormalWireCircularArcMagneticVectorPotential[{r_,\[Phi]_,z_},\[Phi]1_,\[Phi]2_,r1_,z1_]:=
Block[{a,a2,k2,\[Alpha]1,\[Alpha]2,ui,Ahat,ToCartesian,u},
Ahat[\[Alpha]i_]:=
If[Abs[\[Alpha]i]<=\[Pi]/2,
ui=u/.FindRoot[JacobiAmplitude[u,k2]-Abs[\[Alpha]i],{u,0}];
a/r{JacobiDN[ui,k2],
Sign[\[Alpha]i]((1-k2/2)EllipticF[Abs[\[Alpha]i],Sqrt[k2]]+EllipticE[Abs[\[Alpha]i],Sqrt[k2]]),0},
ui=u/.FindRoot[JacobiAmplitude[u,k2]-(\[Pi]-Abs[\[Alpha]i]),{u,0}];
a/r{JacobiDN[ui,k2],
Sign[\[Alpha]i](2(1-k2/2)EllipticF[\[Pi]/2,Sqrt[k2]]+2EllipticE[\[Pi]/2,Sqrt[k2]]-(1-k2/2)EllipticF[\[Pi]-Abs[\[Alpha]i],Sqrt[k2]]-EllipticE[\[Pi]-Abs[\[Alpha]i],Sqrt[k2]]),0}
];

\[Alpha]1=(\[Pi]+\[Phi]-\[Phi]1)/2;
\[Alpha]2=(\[Pi]+\[Phi]-\[Phi]2)/2;
a2=(z1-z)^2+(r1+r)^2;
a=Sqrt[a2];
k2=4 r r1/a2;
Chop[Ahat[\[Alpha]1]-Ahat[\[Alpha]2]]
];


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_}, WireCircularArc[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireCircularArcMagneticInduction[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{_,_,_},WireCircularArc[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireCircularArcMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,_},WireEllipse[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipseMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_}, WireEllipse[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipseMagneticInduction[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{_,_,_},WireEllipse[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipseMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,_},WireEllipsoidalArc[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipsoidalArcMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_}, WireEllipsoidalArc[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipsoidalArcMagneticInduction[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{_,_,_},WireEllipsoidalArc[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:={0,0,0};

NormalWireEllipsoidalArcMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,0};


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{x_,y_,z_},WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:=
Block[{basis,dbasis,equations,t},
basis={-(-1+t)^3,3 (-1+t)^2 t,-3 (-1+t) t^2,t^3};
dbasis={-3 (-1+t)^2,3 (-1+t)^2+6 (-1+t) t,-6 (-1+t) t-3 t^2,3 t^2};
equations=basis.positions;
10^-7 current NIntegrate[dbasis.positions/Sqrt[(p-equations).(p-equations)],{t,0,1},Method->{Automatic,"SymbolicProcessing"->False}]
];


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_}, WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:=Block[{basis,dbasis,equations,t},
basis={-(-1+t)^3,3 (-1+t)^2 t,-3 (-1+t) t^2,t^3};
dbasis={-3 (-1+t)^2,3 (-1+t)^2+6 (-1+t) t,-6 (-1+t) t-3 t^2,3 t^2};
equations=basis.positions;
10^-7 current NIntegrate[Cross[dbasis.positions,(p-equations)]/Sqrt[(p-equations).(p-equations)]^3,{t,0,1},Method->{Automatic,"SymbolicProcessing"->False}]
];


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{x_,y_,z_},WireSpline[positions:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}},current_,color_]]:=
Block[{basis,dbasis,equations,integrand,\[Xi],\[Eta],\[Zeta],t},
basis={-(-1+t)^3,3 (-1+t)^2 t,-3 (-1+t) t^2,t^3};
dbasis={-3 (-1+t)^2,3 (-1+t)^2+6 (-1+t) t,-6 (-1+t) t-3 t^2,3 t^2};
equations=basis.positions;
integrand=(D[Cross[dbasis.positions,({\[Xi],\[Eta],\[Zeta]}-equations)]/Sqrt[({\[Xi],\[Eta],\[Zeta]}-equations).({\[Xi],\[Eta],\[Zeta]}-equations)]^3,#]&/@{\[Xi],\[Eta],\[Zeta]})/.{\[Xi]->x,\[Eta]->y,\[Zeta]->z};
10^-7 current NIntegrate[integrand,{t,0,1},Method->{Automatic,"SymbolicProcessing"->False}]
];


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{x_,y_,z_},WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}]]:=
Plus@@(MagneticVectorPotential[p,#]&/@g);


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_},WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}]]:=Plus@@(MagneticInduction[p,#]&/@g);


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{x_,y_,z_},WireGroup[g:{(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup)..}]]:=
Plus@@(MagneticInductionGradient[p,#]&/@g);


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{x_,y_,z_},WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_]]:=
Plus@@(MagneticVectorPotential[p+offset #,o]&/@Range[0,nRepeat]);


(* ::Input::Initialization:: *)
MagneticInduction[p:{x_,y_,z_},WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_]]:=
Plus@@(MagneticInduction[p+offset #,o]&/@Range[0,nRepeat]);


(* ::Input::Initialization:: *)
MagneticInductionGradient[p:{x_,y_,z_},WireRepeated[o:(_WireSegment|_WireRectangle|_WireCircle|_WireCircularArc|_WireEllipse|_WireEllipsoidalArc|_WireSpline|_WireRepeated|_WireGroup),offset:{_,_,_},nRepeat_]]:=
Plus@@(MagneticInductionGradient[p+offset #,o]&/@Range[0,nRepeat]);


(* ::Input::Initialization:: *)
MagneticVectorPotential[p:{_,_,_},MultipoleSegment[VectorPotentialMultipole[cg:{_,_,_},lim1_,lim2_,mp_List],WireSegment[positions:{left:{_,_,_},right:{_,_,_}},current_,color_]]]:=
Block[{LineSegment,t,s,n,rAbs,\[Phi]},

LineSegment[start:{_,_,_},end:{_,_,_}]:=Block[{v},
v=end-start;
rAbs=Sqrt[(p-cg).(p-cg)];

t=RotationMatrix[{v,{0,0,1}}];
s=RotationMatrix[{-v,{0,0,1}}];

If[rAbs>10^-9,
\[Phi]=VectorAngle[p-cg,v];
s.multipoleWireSegmentMagneticVectorPotential[rAbs,\[Phi],mp],
s.NormalWireSegmentMagneticVectorPotential[t.(p-start),Sqrt[v.v]]
]
];
10^-7 current LineSegment[left,right]

];

multipoleWireSegmentMagneticVectorPotential[r_,\[Phi]_,multipole:{__}]:=
Block[{n},
n=Length[multipole];
{0,0,(((r)^-#)&/@Range[n]).((#[\[Phi]])&/@multipole)}
];

NormalWireSegmentMagneticVectorPotential[{x_,y_,z_},end_]:=
{0,0,-ArcSinh[-z/(x^2+y^2)]+ArcSinh[(end-z)/(x^2+y^2)]};
