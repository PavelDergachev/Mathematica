(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* *)
(* Title: ExamplePackage.m *)
(* Context: *)
(* Author:Jan G. Korvink *)
(* Date: 4.1.2006, Freiburg *)
(* Summary: This package solves the Sudoku game problem *)
(* Package Copyright: GNU GPL *)
(* Package Version: 0.1 *)
(* Mathematica Version: 5.1 *)
(* History: *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)


(* ::Input::Initialization:: *)
(* Disclaimer *)

(* Whereever the GNU GPL is not applicable, the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,MA 02111-1307 USA *)


(* ::Input::Initialization:: *)
(* Disclaimer: *)

(* <one line to give the program's name and a brief idea of what it does.> *)

(* Copyright (C) <year> <name of author> *)

(* This program is free software; *)

(* you can redistribute it and/or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. You should have received a copy of *)

(* the GNU General Public License along with this program;if not, write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,MA 02111-1307 USA *)


(* ::Input::Initialization:: *)
(* Start Package *)
BeginPackage["Sudoku`"];


(* ::Input::Initialization:: *)
(* *)
(* documentation *)
(* *)

ReadSudoku::usage="ReadSudoku[filepath] reads a Sudoku specification from an ASCII file specified by the given path. Each row of the array is on a separate line. Unoccupied cells are indicated by a \".\", occupied cells by their digit entries. Example:\n\t ..3....51\n\t 5.2..64..\n\t ..7.5....\n\t ...63.7..\n\t 2..7.8..6\n\t ..4.21...\n\t ....7.8..\n\t ..81..6.9\n\t 17....5..\n The Sudoku is returned as an integer array with zeros in the unoccupied cells, and integer digits in the occupied cells.";

DrawSudoku::usage="DrawSudoku[array] draws a picture of the Sudoku specified by a 9x9 integer array. Unoccupied squares have the value 0, occupied squares have a value between 1 and 9.";

SolveSudoku::usage="SolveSudoku[array] finds the possible solutions of a partially specified Sudoku given by the array. The function returns a list of zero or more solutions, each again in the form of an array.";

(* constructors *)

(* selectors *)

(* predicates *)

(* functions *)



(* ::Input::Initialization:: *)
(* *)
(* options docu *)
(* *)


(* ::Input::Initialization:: *)
(* *)
(* error messages *)
(* *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
(* *)
(* private imports *)
(* *)


(* ::Input::Initialization:: *)
fileName=StringJoin[NotebookDirectory[],"ExactCover.m"];
Get[fileName]


(* ::Input::Initialization:: *)
(* *)
(* implementation part *)
(* *)

(* constructor *)
(* *)


(* ::Input::Initialization:: *)
(* *)
(* define your options *)
(* *)


(* ::Input::Initialization:: *)
(* selector *)
(* *)


(* ::Input::Initialization:: *)
(* predicates *)
(* *)


(* ::Input::Initialization:: *)
(* private functions *)
(* *)


(* ::Input::Initialization:: *)
sudokuDigitQ[d_Integer]:=MemberQ[Range[9],d];


(* ::Input::Initialization:: *)
rcToBlock[r_?sudokuDigitQ,c_?sudokuDigitQ]:=(Quotient[r-1,3]3)+(Quotient[c-1,3]+1);


(* ::Input::Initialization:: *)
rcToEntry[r_?sudokuDigitQ,c_?sudokuDigitQ]:=(Quotient[r-1,1]9)+(Quotient[c-1,1]+1);


(* ::Input::Initialization:: *)
makeIntegerSudoku[p:{{_String,_String,_String,_String,_String,_String,_String,_String,_String}..}]:=Map[If[#=="."||#==" "||#=="0",0,ToExpression[#]]&,p,{2}];


(* ::Input::Initialization:: *)
generalConstraint[p_]:=Normal[SparseArray[{p->1},81]];
rowConstraint[r_,d_]:=generalConstraint[((d-1)9+r)];
columnConstraint[c_,d_]:=generalConstraint[((d-1)9+c)];
blockConstraint[{r_,c_},d_]:=generalConstraint[((d-1)9+rcToBlock[r,c])];
cellConstraint[{r_,c_},d_]:=generalConstraint[rcToEntry[r,c]];


(* ::Input::Initialization:: *)
makeGivenLine[{r_?sudokuDigitQ,c_Integer?sudokuDigitQ},d_Integer]:=Join[rowConstraint[r,d],columnConstraint[c,d],blockConstraint[{r,c},d],cellConstraint[{r,c},d]];


(* ::Input::Initialization:: *)
freeMovesSudoku[p:{{_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer}..}]:=Module[{rowSets,colSets,blockSets,cellSets,makeCellSet},

makeCellSet[d_,{r_?sudokuDigitQ,c_?sudokuDigitQ}]:=If[d==0,
Intersection[rowSets[[r]],colSets[[c]],blockSets[[rcToBlock[r,c]]]],{d}
];

rowSets=Complement[Range[9],#]&/@(Select[Union[#],(#!=0)&]&/@p);
colSets=Complement[Range[9],#]&/@(Select[Union[#],(#!=0)&]&/@Transpose[p]);
blockSets=Flatten[Map[Complement[Range[9],Select[Flatten[Transpose[#]],(#!=0)&]]&,Partition[#,3]&/@(Transpose[#]&/@Partition[p,3]),{2}],1];

Return[MapIndexed[makeCellSet,p,{2}]]
];


(* ::Input::Initialization:: *)
extractSolution[sol:{{_Integer,_Integer,_Integer,_Integer}..}]:=(Quotient[#-1,9]+1)&/@Flatten[#[[1]]&/@Sort[sol,(#1[[-1]]<#2[[-1]])&]];


(* ::Input::Initialization:: *)
makeTableLine[ds:{(_Integer)..},{r_,c_}]:=makeGivenLine[{r,c},#]&/@ds;


(* ::Input::Initialization:: *)
(* public functions *)
(* *)


(* ::Input::Initialization:: *)
ReadSudoku[f_String]:=Module[{s,res},
s=OpenRead[f];
res=Partition[Flatten[ReadList[s,Character,RecordSeparators->{"\n"},RecordLists->True]],9];
Close[s];
Return[makeIntegerSudoku[res]]
];


(* ::Input::Initialization:: *)
DrawSudoku[p:{{_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer}..}]:=Module[{drawLabel,grid},
drawLabel[l_Integer,{i_Integer,j_Integer}]:=Text[If[l==0," ",ToString[l]],{j,10-i},{0,0}];
grid={Thickness[.004],Line[{{.5,#-.5},{9.5,#-.5}}]&/@Range[10],
Line[{{#-.5,.5},{#-.5,9.5}}]&/@Range[10],Thickness[.012],Line[{{.5,3#-2.5},{9.5,3#-2.5}}]&/@Range[4],
Line[{{3#-2.5,.5},{3#-2.5,9.5}}]&/@Range[4]};
Graphics[{grid,MapIndexed[drawLabel,p,{2}]},AspectRatio->Automatic,PlotRange->All]
];


(* ::Input::Initialization:: *)
SolveSudoku[p:{{_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer,_Integer}..}]:=Module[{exactCoverTable,theSolutions,myRecursionLimit},
exactCoverTable=Flatten[MapIndexed[makeTableLine,freeMovesSudoku[p],{2}],2];
myRecursionLimit=$RecursionLimit;
$RecursionLimit=10000;
theSolutions=ExactCover[exactCoverTable];
$RecursionLimit=myRecursionLimit;
Partition[extractSolution[#],9]&/@theSolutions
];


(* ::Input::Initialization:: *)
(* representors *)
(* *)


(* ::Input::Initialization:: *)
(* Begin Private *)
End[]


(* ::Input::Initialization:: *)
(* Protect[] *)
EndPackage[] 

