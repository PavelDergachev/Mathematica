(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* *)
(* Title: ExactCover.m *)
(* Context: *)
(* Author:Jan G. Korvink *)
(* Date: 3.1.2006, Karlsruhe *)
(* Summary: This function solves the exact cover problem *)
(* Package Copyright: GNU GPL *)
(* Package Version: 0.1 *)
(* Mathematica Version: 5.1 *)
(* History: *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)


(* ::Input::Initialization:: *)
(* Disclaimer *)

(* Whereever the GNU GPL is not applicable, the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,MA 02111-1307 USA *)


(* ::Input::Initialization:: *)
(* Disclaimer: *)

(* <one line to give the program's name and a brief idea of what it does.> *)

(* Copyright (C) <year> <name of author> *)

(* This program is free software; *)

(* you can redistribute it and/or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. You should have received a copy of *)

(* the GNU General Public License along with this program;if not, write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,MA 02111-1307 USA *)


(* ::Input::Initialization:: *)
(* Start Package *)
BeginPackage["ExactCover`"];


(* ::Input::Initialization:: *)
(* *)
(* documentation *)
(* *)
ExactCover::Usage="ExactCover[matrix] chooses a subset of rows of the rectangular matrix which have exactly one nonzero element in each column. The function is useful for solving a variety of other problems, such as games, timetables, etc.";

PlotAlgorithm::usage="PlotAlgorithm->True forces ExactCover to draw a picture illustrating the operation of the algorithm. This is useful for debugging, and for didactic purposes.";

(* constructors *)

(* selectors *)

(* predicates *)

(* functions *)



(* ::Input::Initialization:: *)
(* *)
(* options docu *)
(* *)


(* ::Input::Initialization:: *)
(* *)
(* error messages *)
(* *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
(* *)
(* private imports *)
(* *)


(* ::Input::Initialization:: *)
(* *)
(* implementation part *)
(* *)

(* constructor *)
(* *)


(* ::Input::Initialization:: *)
(* *)
(* define your options *)
(* *)


(* ::Input::Initialization:: *)
Options[ExactCover]={PlotAlgorithm->False};



(* ::Input::Initialization:: *)
(* selector *)
(* *)


(* ::Input::Initialization:: *)
(* predicates *)
(* *)


(* ::Input::Initialization:: *)
(* private functions *)
(* *)


(* ::Input::Initialization:: *)
(* public functions *)
(* *)


(* ::Input::Initialization:: *)
ExactCover[m:{{(_)..}..},opts___]:=Module[{nr,nc,ne,cnt,buildLinkedList,DrawState,search,CoverColumn, UncoverColumn,ev,eu,ed,el,er,en,o,myPlotRange,sol={},plotAlgorithm},

(* oooooooooooooooooooooooooooooooooooooooooooo
This function builds the linked list data structure of the matrix m. The list elements are symbols in the local context. This is slower that using lists, but I wanted to follow Knuth's paper closely, very close to the text, thereby avoiding any programming paradigm. This is possible through using Mathematica's symbol table.
oooooooooooooooooooooooooooooooooooooooooooo *)
buildLinkedList[]:=Block[{cnt,nz,cc,rr,nnz},
(* The zeroth Data Object points to the first column of the header line. We need it for the case where all rows and columns of the matrix are dropped! *)
el[0]=nc;
er[0]=1;
(* We build a matrix that numbers the nonzero entries. The first row represents the columns headers of the matrix, following Knuth's paper. Here, cnt is a counter. *)
cnt=nc+1;
nz=Join[{Range[nc]},Table[Table[
If[m[[r,c]]!=0,
cnt++,0
],{c,1,nc}],
{r,1,nr}]];
nnz=cnt-nc-1;
(* Instantiate the column names *)
Table[en[i]=i,{i,1,nc}];
(* Instantiate the horizontal links *)
Table[Table[
If[nz[[r,c]]!=0,
cc=Mod[c,nc]+1;
While[nz[[r,cc]]==0,cc=Mod[cc,nc]+1];
er[nz[[r,c]]]=nz[[r,cc]];
el[nz[[r,cc]]]=nz[[r,c]];
ec[nz[[r,c]]]=c
],
{c,1,nc}],
{r,1,nr+1}];
(* Link in the object link *)
el[1]=0;
er[nc]=0;
(* Instantiate the vertical links *)
Table[Table[
If[nz[[r,c]]!=0,
rr=Mod[r,nr+1]+1;
While[nz[[rr,c]]==0,rr=Mod[rr,nr+1]+1];
ed[nz[[r,c]]]=nz[[rr,c]];
eu[nz[[rr,c]]]=nz[[r,c]];
],
{r,1,nr+1}],
{c,1,nc}];
(* Instantiate the column counts *)
cnt=1;
(es[cnt++]=#)&/@((Plus@@#)&/@Map[(If[#!=0,1,0])&,Transpose[m],{2}]);
Return[]
];

(* oooooooooooooooooooooooooooooooooooooooooooo
Draw a graphic of the current state of the data structure
oooooooooooooooooooooooooooooooooooooooooooo *)
DrawState[]:=Block[{drawBlock,drawDownLinks,drawUpLinks,drawLeftLinks,drawRightLinks,nr,nc,cnt,nz,pos,r,c,pic},
{nr,nc}=Dimensions[m];
cnt=nc+1;
nz=Join[{Range[nc]},Table[Table[
If[m[[r,c]]!=0,
cnt++,0
],{c,1,nc}],
{r,1,nr}]];

(* The integer coordinates of all table elements *)
pos=Select[Flatten[Table[Table[
If[nz[[r,c]]!=0,
{r,c},0
],{c,1,nc}],
{r,1,nr+1}],1],(Head[#]===List)&];

coords[{i_Integer,j_Integer}]:={j+1,nr-i};

myPlotRange={{-.5,nc+2.5},{-2,nr+.5}};

drawBlock[val_,{i_,j_}]:=Block[{x,y,col},
If[i==1,
col=RGBColor[0,1,0],col=Hue[.17]
];
{x,y}=coords[{i,j}];
If[val!=0,{col,Rectangle[{x,y},{x+.5,y+.5}],
GrayLevel[0];
Text[val,{x,y}];
RGBColor[1,0,0],
Disk[{x+.1,y+.1},.05],Disk[{x+.4,y+.1},.05],Disk[{x+.4,y+.4},.05],Disk[{x+.1,y+.4},.05]},
{}
]
];
drawDownLinks[val_,{i_,j_}]:=Block[{r,c},
If[val!=0,
{r,c}=pos[[ed[nz[[i,j]]]]];
If[r!=1,
{Line[{coords[{i,j}]+{.1,.1},coords[{r,c}]+{.1,.4}}]},
{Line[{coords[{i,j}]+{.1,.1},coords[{nr,j}]+{.1,-2}}],
Line[{coords[{1,j}]+{.1,.4},coords[{1,j}]+{.1,1.4}}]}
],{}
]
];
drawUpLinks[val_,{i_,j_}]:=Block[{r,c},
If[val!=0,
{r,c}=pos[[eu[nz[[i,j]]]]];
If[i!=1,
{Line[{coords[{i,j}]+{.4,.4},coords[{r,c}]+{.4,.1}}]},
{Line[{coords[{1,j}]+{.4,.4},coords[{1,j}]+{.4,1.4}}],
Line[{coords[{r,j}]+{.4,.1},coords[{nr,j}]+{.4,-2}}]}
],{}
]
];
drawRightLinks[val_,{i_,j_}]:=Block[{r,c},
If[val!=0,
If[er[nz[[i,j]]]>0,
{r,c}=pos[[er[nz[[i,j]]]]],
{r,c}={1,-1}
];
If[c>j,
{Line[{coords[{i,j}]+{.4,.4},coords[{r,c}]+{.1,.4}}]},
If[i==1,
{Line[{coords[{i,j}]+{.4,.4},coords[{i,nc}]+{1.4,.4}}],
Line[{coords[pos[[er[0]]]]+{.1,.4},coords[{1,1}]+{-1.1,.4}}]},
{Line[{coords[{i,j}]+{.4,.4},coords[{i,nc}]+{1.4,.4}}],
Line[{coords[{r,c}]+{.1,.4},coords[{r,1}]+{-1.1,.4}}]}
]
],
{}
]
];
drawLeftLinks[val_,{i_,j_}]:=Block[{r,c},
If[val!=0,
If[el[nz[[i,j]]]>0,
{r,c}=pos[[el[nz[[i,j]]]]],
{r,c}={1,-1}
];
If[c<j&&c!=-1,
{Line[{coords[{i,j}]+{.1,.1},coords[{r,c}]+{.4,.1}}]},
If[i==1,
{Line[{coords[pos[[er[0]]]]+{.1,.1},coords[{1,1}]+{-1.1,.1}}],
Line[{coords[pos[[el[0]]]]+{.4,.1},coords[{i,nc}]+{1.4,.1}}]},
{Line[{coords[{i,j}]+{.1,.1},coords[{i,1}]+{-1.1,.1}}],
Line[{coords[{r,c}]+{.4,.1},coords[{r,nc}]+{1.4,.1}}]}
]
],
{}
]
];

pic={RGBColor[0,0,1],Rectangle[{.5,nr-1},{1,nr-1+.5}],
RGBColor[1,0,0],
Disk[{.5+.4,nr-1+.1},.05],Disk[{.5+.4,nr-1+.4},.05]};

For[c=er[0],c!=0,c=er[c],
{i,j}=pos[[c]];
pic={pic,
drawBlock[nz[[i,j]],{i,j}],drawDownLinks[nz[[i,j]],{i,j}],
drawUpLinks[nz[[i,j]],{i,j}],
drawRightLinks[nz[[i,j]],{i,j}],
drawLeftLinks[nz[[i,j]],{i,j}]};
For[r=ed[c],r!=c,r=ed[r],
{i,j}=pos[[r]];
pic={pic,
drawBlock[nz[[i,j]],{i,j}],drawDownLinks[nz[[i,j]],{i,j}],
drawUpLinks[nz[[i,j]],{i,j}],
drawRightLinks[nz[[i,j]],{i,j}],
drawLeftLinks[nz[[i,j]],{i,j}]};
]
];
Graphics[pic,PlotRange->myPlotRange,AspectRatio->Automatic]

];

(* oooooooooooooooooooooooooooooooooooooooooooo
Taking out a column
oooooooooooooooooooooooooooooooooooooooooooo *)
CoverColumn[c_Integer]:=Block[{i,j},
el[er[c]]=el[c];
er[el[c]]=er[c];
For[i=ed[c],i!=c,i=ed[i],
For[j=er[i],j!=i,j=er[j],
eu[ed[j]]=eu[j];
ed[eu[j]]=ed[j];
es[ec[j]]=es[ec[j]]-1
]
];
If[plotAlgorithm,Show[DrawState[]]]
];

(* oooooooooooooooooooooooooooooooooooooooooooo
Reinserting a column
oooooooooooooooooooooooooooooooooooooooooooo *)
UncoverColumn[c_Integer]:=Block[{i,j},
For[i=eu[c],i!=c,i=eu[i],
For[j=el[i],j!=i,j=el[j],
es[ec[j]]=es[ec[j]]+1;
eu[ed[j]]=j;
ed[eu[j]]=j
]
];
el[er[c]]=c;
er[el[c]]=c;
If[plotAlgorithm,Show[DrawState[]]]
];

(* oooooooooooooooooooooooooooooooooooooooooooo
The search function
oooooooooooooooooooooooooooooooooooooooooooo *)
search[k_Integer]:=
Block[{r,c,s,l,soll,j},
If[er[0]==0,
AppendTo[sol,Table[Block[{soll},
j=s=o[l];
soll={en[ec[s]]};
While[(j=er[j])!=s,soll={soll,en[ec[j]]}];
Sort[Flatten[soll]]
],{l,0,k-1}
]
];
Return[]
];
(* Choose the column with the lowest number of branches *)
s=\[Infinity];
For[j=er[0],j!=0,j=er[j],
If[j==0,Break[]];
If[es[j]<s,
c=j;
s=es[j]
]
];
(* Cover column c *)
CoverColumn[c];

(* Loop *)
For[r=ed[c],r!=c,r=ed[r],
o[k]=r;
For[j=er[r],j!=r,j=er[j],
CoverColumn[ec[j]];
];
search[k+1];
r=o[k];
c=ec[r];
For[j=el[r],j!=r,j=el[j],
UncoverColumn[ec[j]]
]
];
(* Uncover column c and return *)
UncoverColumn[c]
];

(* oooooooooooooooooooooooooooooooooooooooooooo
The code
oooooooooooooooooooooooooooooooooooooooooooo *)

(* Extract the user options *)
plotAlgorithm=PlotAlgorithm/.{opts}/.Options[ExactCover];

(* Determine the problem size *)
{nr,nc}=Dimensions[m];
ne=nr*nc;

(* Establish the linked list data structure *)
buildLinkedList[];

(* Draw a picture of the starting state *)
If[plotAlgorithm,Show[DrawState[]]];

(* Find all exact covers *)
search[0];

(* Return the accumulated solutions *)
Return[sol]

];


(* ::Input::Initialization:: *)
(* representors *)
(* *)


(* ::Input::Initialization:: *)
(* Begin Private *)
End[]


(* ::Input::Initialization:: *)
(* Protect[] *)
EndPackage[] 




